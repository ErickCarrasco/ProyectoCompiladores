package main;

import java_cup.runtime.*;
import java.util.*;
import java.io.FileReader;
//import Nodo;

parser code
{:
        public int count=1;
        public static Nodo padre;
        public static int syntacticErrors = 0;

        public String token_name_from_id(int id){
                //por medio de SYM.JAVA
                switch(id){
                case 0: return "EOF";
                case 1: return "error";
                case 2: return "BOOL";
                case 3: return "LETTERS";
                case 4: return "INTEGER";
                case 5: return "NOTHING";
                case 6: return "ID";
                case 7: return "LPAR";
                case 8: return "RPAR";
                case 9: return "LSBRACKET";
                case 10: return "RSBRACKET";
                case 11: return "LCBRACKET";
                case 12: return "RCBRACKET";
                case 13: return "COLON";
                case 14: return "ASSIGNMENT";
                case 15: return "SEMICOLON";
                case 16: return "COMMA";
                case 17: return "OPREL";
                case 18: return "OPSUMA";
                case 19: return "OPMULT";
                case 20: return "OPRES";
                case 21: return "VECTOR";
                case 22: return "CASE";
                case 23: return "IF";
                case 24: return "WHILE";
                case 25: return "LOOP";
                case 26: return "ELSIF";
                case 27: return "ELSE";
                case 28: return "FUNC";
                case 29: return "PIPE";
                case 30: return "SCAN";
                case 31: return "SOUT";
                case 32: return "SOUTLN";
                case 33: return "BREAK";
                case 34: return "DEFAULT";
                case 35: return "SWITCH";
                case 36: return "INT";
                case 37: return "DEF";
                case 38: return "FAKER";
                case 39: return "PAYBACK";
                case 40: return "EACH";
                case 41: return "INIT";
                case 42: return "NOT";
                case 43: return "CHAR";
                default: return "N/A";
                }
        }

        public void syntax_error(Symbol s){
                report_error("Error sintáctico. No se esperaba el siguiente token: <" + s.value + ">. Línea: " + (s.right + 1) + ", Columna: " + (s.left + 1) + 	"\n", null);

                syntacticErrors++;

                List expected = expected_token_ids();
                if (expected.size() != 0) {
                        int id;
                        System.out.println("Se esperaba...");
                        for (int i = 0; i < expected.size(); i++) {
            	                id = (int) expected.get(i);
            	                if (i == expected.size() - 1) {
            		                System.out.println(token_name_from_id(id));
            	                } else {
            		                System.out.print(token_name_from_id(id) + " | ");
            	                }
                        }
                }

        }

:}

//Lexemas
terminal   BOOL, LETTERS, INTEGER, NOTHING;
terminal   ID;


//Palabras reservadas, y Operadores
terminal LPAR, RPAR, LSBRACKET, RSBRACKET, LCBRACKET, RCBRACKET, COLON, ASSIGNMENT, SEMICOLON, COMMA;

terminal OPREL, OPSUMA, OPMULT, OPRES, VECTOR, CASE, IF, WHILE, LOOP, ELSIF, ELSE, FUNC, PIPE;

terminal SCAN, SOUT, SOUTLN, BREAK, DEFAULT, SWITCH, INT, DEF, FAKER, PAYBACK, EACH, INIT, NOT;

terminal CHAR;

//No TERMINALES

non terminal Program;
non terminal declaraciones;
non terminal decl_v_e;
non terminal declaracion_vec;
non terminal tipo;
non terminal tipoVS;
non terminal values;
non terminal ifStatement;
non terminal expression;
non terminal expresion_simple;
non terminal termino;
non terminal factor;

non terminal signo;
non terminal declaracionSimple;
non terminal functions;
non terminal params;
non terminal elsiffer;
non terminal proposition;
non terminal asignacion;
non terminal forLoop;
non terminal switchCase;
non terminal cases;
non terminal body;
non terminal vectorData;
non terminal empty;
non terminal lista_ID;
non terminal lista_expresiones;
non terminal imprimir;
non terminal scanear;

start with Program;

Program ::= INIT:initProg LPAR:leftPar RPAR:rightPar LCBRACKET:left_cbracket body:mainbody RCBRACKET:right_cbracket 
        {:
                Nodo nodo = new Nodo();
                nodo.setEtiqueta("INITIALIZE");
                nodo.setID(parser.count);
                parser.count++;

                //Terminal init
                Nodo initProgn = new Nodo();
                initProgn.setEtiqueta("INITIAL");
                initProgn.setID(parser.count);
                initProgn.setValor(initProg.toString());
                parser.count++;
                //initp.setValor(id);

                nodo.addHijos(initProgn);

                //Terminal leftPar
               // Nodo leftParn = new Nodo();
                //leftParn.setEtiqueta("Left Parenthesis");
                //leftParn.setID(parser.count);
                //leftParn.setValor(leftPar.toString());
                //parser.count++;

                //nodo.addHijos(leftParn);

                //Terminal rightPar
                //Nodo rightParn = new Nodo();
                //rightParn.setEtiqueta("Right Parenthesis");
                //rightParn.setID(parser.count);
                //rightParn.setValor(")");
                //parser.count++;

                //nodo.addHijos(rightParn);

                //Terminal left C bracket
                //Nodo left_cbracketn = new Nodo();
                //left_cbracketn.setEtiqueta("Left C Bracket");
                //left_cbracketn.setID(parser.count);
                //left_cbracketn.setValor("{");
                //parser.count++;
                //nodo.addHijos(left_cbracketn);

                //Non terminal body
                nodo.addHijos((Nodo) mainbody);

                //Terminal Right C Bracket
                //Nodo right_cbracketn = new Nodo();
                //right_cbracketn.setEtiqueta("Right C Bracket");
                //right_cbracketn.setID(parser.count);
                //right_cbracketn.setValor("}");
                //parser.count++;
                //nodo.addHijos(right_cbracketn);

                parser.padre = nodo;

                RESULT = nodo;
        :}
        ;


declaraciones ::=  DEF  tipo:typeV  lista_ID:lista_IDs SEMICOLON {:
                Nodo declaraciones = new Nodo();
                declaraciones.setEtiqueta("Declaracion");
                declaraciones.setID(parser.count);
                parser.count++;

                declaraciones.addHijos((Nodo) typeV);
                declaraciones.addHijos((Nodo)lista_IDs);

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;

                declaraciones.addHijos(semicolonN);
                //parser.padre = declaraciones;

                RESULT = declaraciones;

                :};

body::= proposition:prop body:bod 
        {:
                
                Nodo bodyn = new Nodo();
                bodyn.setEtiqueta("Body");
                bodyn.setID(parser.count);
                bodyn.setValor("Body constr");
                parser.count++;

                //Nodo props = new Nodo();
                //props.setEtiqueta("proposition");
                //props.setID(parser.count);
                //props.setValor(prop.toString());
                //parser.count++;

                bodyn.addHijos((Nodo) prop);
                if(bod!=null){
                        bodyn.addHijos(((Nodo) bod).getHijos());
                }
                //bodyn.addHijos((Nodo) bod );

                //parser.padre = bodyn;

                RESULT = bodyn;
                


        :}
        | functions body
        | {:

                /*
                Nodo bodyn = new Nodo();
                bodyn.setEtiqueta("Body");
                bodyn.setID(parser.count);
                bodyn.setValor("Body constr");
                parser.count++;

                Nodo empty = new Nodo();
                empty.setEtiqueta("EMPTY");
                empty.setID(parser.count);
                empty.setValor("null");
                parser.count++;
                
                bodyn.addHijos(empty);
                
                RESULT = bodyn;
                */
        :};

proposition ::= WHILE expression LCBRACKET proposition RCBRACKET
        | forLoop:forl{:
                RESULT = forl;
        :}
        | ifStatement:ifS{:
                RESULT = ifS;
        :}
        | switchCase:sc{:
                RESULT = sc;
        :}
        | declaraciones:decl{:
                //Nodo proposition = new Nodo();
                //proposition.setID(parser.count++);
                //proposition.setEtiqueta("propositionDecl");
                //parser.count++;

                //proposition.addHijos((Nodo) decl);

                //parser.padre = proposition;
                RESULT = decl;
                
        :}
        | declaracionSimple: declS{:
               /*
                Nodo proposition = new Nodo();
                proposition.setID(parser.count);
                proposition.setEtiqueta("propositionDeclSimple");
                parser.count++;

                proposition.addHijos((Nodo)declS);
                parser.padre = proposition;
                */
                RESULT = declS;
        :}
        | imprimir:printer {:
                //Nodo printing = new Nodo();
                //printing.setID(parser.count);
                //printing.setEtiqueta("Printer");
                //printing.setValor(":=");
                //parser.count++;

                //printing.addHijos((Nodo) printer);
                //parser.padre = printing;
                RESULT = printer;


        :}
        | scanear:scan{:
                RESULT = scan;
        :}
        | ID:idP ASSIGNMENT:as expression:ex SEMICOLON {:
                Nodo asignacionID = new Nodo();
                asignacionID.setEtiqueta("asignacion a valor");
                asignacionID.setID(parser.count);
                parser.count++;

                Nodo idData = new Nodo();
                idData.setEtiqueta("ID");
                idData.setID(parser.count);
                idData.setValor(idP.toString());
                parser.count++;

                asignacionID.addHijos(idData);

                asignacionID.addHijos((Nodo) ex);

                RESULT = asignacionID;

        
        :};

imprimir ::= SOUT:st LPAR:lP ID:idP RPAR:rP SEMICOLON {:
                Nodo impresion = new Nodo();
                impresion.setEtiqueta("Impresion");
                impresion.setID(parser.count);
                impresion.setValor("printer");

                parser.count++;

                Nodo souter = new Nodo();
                souter.setEtiqueta("system out");
                souter.setID(parser.count);
                souter.setValor(st.toString());

                impresion.addHijos(souter);
                parser.count++;

                Nodo idData = new Nodo();
                idData.setEtiqueta("ID");
                idData.setID(parser.count);
                idData.setValor(idP.toString());
                parser.count++;

                impresion.addHijos(idData);

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;
                
                impresion.addHijos(semicolonN);

                RESULT = impresion;

        :}
        | SOUTLN:stl LPAR ID:idP RPAR SEMICOLON {:
                Nodo impresion = new Nodo();
                impresion.setEtiqueta("Impresion con Salto de linea");
                impresion.setID(parser.count);
                impresion.setValor("printerLN");

                parser.count++;

                Nodo souter = new Nodo();
                souter.setEtiqueta("system out ln");
                souter.setID(parser.count);
                souter.setValor(stl.toString());

                impresion.addHijos(souter);
                parser.count++;

                Nodo idData = new Nodo();
                idData.setEtiqueta("ID");
                idData.setID(parser.count);
                idData.setValor(idP.toString());
                parser.count++;

                impresion.addHijos(idData);

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;
                
                impresion.addHijos(semicolonN);

                RESULT = impresion;

        
        :}
        | SOUT:st LPAR values:vals RPAR SEMICOLON {:

                Nodo impresion = new Nodo();
                impresion.setEtiqueta("Impresion");
                impresion.setID(parser.count);
                impresion.setValor("printer");

                parser.count++;

                Nodo souter = new Nodo();
                souter.setEtiqueta("system out");
                souter.setID(parser.count);
                souter.setValor(st.toString());

                impresion.addHijos(souter);
                parser.count++;

                impresion.addHijos((Nodo) vals);

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;
                
                impresion.addHijos(semicolonN);

                RESULT = impresion;
        
        :}
        | SOUTLN:stl LPAR values:vals RPAR SEMICOLON{:
                Nodo impresion = new Nodo();
                impresion.setEtiqueta("Impresion con Salto de linea");
                impresion.setID(parser.count);
                impresion.setValor("printerLN");

                parser.count++;

                Nodo souter = new Nodo();
                souter.setEtiqueta("system out ln");
                souter.setID(parser.count);
                souter.setValor(stl.toString());

                impresion.addHijos(souter);
                parser.count++;

                impresion.addHijos((Nodo) vals);


                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;
                
                impresion.addHijos(semicolonN);

                RESULT = impresion;
        
        :};


forLoop::= LOOP:looper LSBRACKET proposition:prop RSBRACKET EACH:eachW LPAR ID:idP RPAR{:

:};

declaracionSimple ::= DEF tipo:type ID:idP decl_v_e:dv {:
                Nodo DeclSimple = new Nodo();
                DeclSimple.setEtiqueta("Decl Simple");
                DeclSimple.setID(parser.count);
                DeclSimple.setValor("Declaracion simple");
                parser.count++;

                Nodo definer = new Nodo();
                definer.setEtiqueta("def");
                definer.setID(parser.count);
                definer.setValor("DEF");
                parser.count++;

                DeclSimple.addHijos(definer);
                DeclSimple.addHijos((Nodo) type);
                
                Nodo idData = new Nodo();
                idData.setEtiqueta("ID");
                idData.setID(parser.count);
                idData.setValor(idP.toString());
                parser.count++;

                DeclSimple.addHijos(idData);
                DeclSimple.addHijos((Nodo) dv);

                //parser.padre = DeclSimple;

                RESULT = DeclSimple;

        :}
;

functions::= FUNC tipo ID LPAR params RPAR LCBRACKET body PAYBACK values SEMICOLON RCBRACKET;

params::= tipo ID
    | ID;

scanear::= ID:idP ASSIGNMENT SCAN:scanP LPAR tipo:typeV RPAR SEMICOLON{:
                Nodo scanear = new Nodo();
                scanear.setEtiqueta("Scanner");
                scanear.setID(parser.count);
                scanear.setValor("");

                parser.count++;

                Nodo idData = new Nodo();
                idData.setEtiqueta("ID");
                idData.setID(parser.count);
                idData.setValor(idP.toString());
                parser.count++;

                scanear.addHijos(idData);

                Nodo scanerW = new Nodo();
                scanerW.setEtiqueta("scaner");
                scanerW.setID(parser.count);
                scanerW.setValor(scanP.toString());
                parser.count++;

                scanear.addHijos(scanerW);

                scanear.addHijos((Nodo)typeV);

                RESULT = scanear;
                

:};

lista_ID ::= ID lista_ID{:

        :}
        | COMMA lista_ID
        | empty;

decl_v_e ::= SEMICOLON {:
                Nodo declV = new Nodo();
                declV.setEtiqueta("decl Val");
                declV.setID(parser.count);
                declV.setValor("D V");
                parser.count++;

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;

                declV.addHijos( semicolonN );

                //parser.padre = declV;

                RESULT = declV;
                
        :}
        |   asignacion:asign {:
                Nodo asigner = new Nodo();
                asigner.setEtiqueta("Asignacion");
                asigner.setID(parser.count);
                asigner.setValor("=");
                parser.count++;

                asigner.addHijos((Nodo) asign);

                RESULT = asigner;
        :};

asignacion ::= ASSIGNMENT:as values:vals SEMICOLON{:
                Nodo asignado = new Nodo();
                asignado.setEtiqueta("Assignment con value");
                asignado.setID(parser.count);
                asignado.setValor("=");
                parser.count++;

                Nodo asigner = new Nodo();
                asigner.setEtiqueta("ASSIGNMENT");
                asigner.setID(parser.count);
                asigner.setValor(as.toString());
                parser.count++;

                asignado.addHijos(asigner);
                asignado.addHijos((Nodo) vals);

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;

                asignado.addHijos(semicolonN);
                //parser.padre = asignado;

                RESULT = asignado;



        :}
        | ASSIGNMENT:as NOTHING:nh SEMICOLON {:
                Nodo asignado = new Nodo();
                asignado.setEtiqueta("Assignment void");
                asignado.setID(parser.count);
                asignado.setValor("=");
                parser.count++;

                Nodo asigner = new Nodo();
                asigner.setEtiqueta("ASSIGNMENT");
                asigner.setID(parser.count);
                asigner.setValor(as.toString());
                parser.count++;

                asignado.addHijos(asigner);

                Nodo voidV = new Nodo();
                voidV.setEtiqueta("Void");
                voidV.setID(parser.count);
                voidV.setValor(nh.toString());
                parser.count++;

                asignado.addHijos(voidV);

                Nodo semicolonN = new Nodo();
                semicolonN.setEtiqueta("semicolon");
                semicolonN.setID(parser.count);
                semicolonN.setValor(";");
                parser.count++;

                asignado.addHijos(semicolonN);

                RESULT = asignado;

        :};


tipo ::= 
        INT {:
                Nodo declI = new Nodo();
                declI.setEtiqueta("Integer");
                declI.setID(parser.count);
                declI.setValor("INT");
                parser.count++;  

                RESULT = declI;
        :}|
        FAKER {:
                Nodo declF = new Nodo();
                declF.setEtiqueta("boolean");
                declF.setID(parser.count);
                declF.setValor("FAKER");
                parser.count++;  

                RESULT = declF;
        :}|
        CHAR{:
                Nodo declC = new Nodo();
                declC.setEtiqueta("character");
                declC.setID(parser.count);
                declC.setValor("CHAR");
                parser.count++;  

                RESULT = declC;
        :};

tipoVS ::= DEF VECTOR ID ASSIGNMENT vectorData;

vectorData ::= LSBRACKET vectorData RSBRACKET
        | values COMMA;

values ::= BOOL:booleanV {:
                Nodo boolFaker = new Nodo();
                boolFaker.setEtiqueta("val Faker");
                boolFaker.setID(parser.count);
                boolFaker.setValor(booleanV.toString());
                parser.count++;

                RESULT = boolFaker;
        :}
        | LETTERS:lCh {:
                Nodo letterChar = new Nodo();
                letterChar.setEtiqueta("val Char");
                letterChar.setID(parser.count);
                letterChar.setValor(lCh.toString());
                parser.count++;

                RESULT = letterChar;
        :}
        | INTEGER:intV {:
                Nodo intVal = new Nodo();
                intVal.setEtiqueta("int val");
                intVal.setID(parser.count);
                intVal.setValor(intV.toString());
                parser.count++;

                RESULT = intVal;

        :}
        ;

//ifStatement::= ifEmp | ifNEmp;

//ifEmp::= IF expression LCBRACKET proposition RCBRACKET elsiffer;

//ifNEmp::= IF expression LCBRACKET proposition RCBRACKET;

ifStatement ::= IF:iferW  expression:ex  LCBRACKET proposition:prop RCBRACKET elsiffer:elsif{:
                Nodo ifState = new Nodo();
                ifState.setID(parser.count);
                ifState.setEtiqueta("if State");
                parser.count++;

                Nodo ifer = new Nodo();
                ifer.setID(parser.count);
                ifer.setEtiqueta("if w");
                ifer.setValor(iferW.toString());
                parser.count++;

                ifState.addHijos(ifer);
                ifState.addHijos((Nodo) ex);
                ifState.addHijos((Nodo) prop);
                ifState.addHijos((Nodo) elsif);

                RESULT = ifState;

:};

elsiffer::= ELSIF:elsifer expression:ex  LCBRACKET proposition:prop RCBRACKET elsiffer:elseR{:
                Nodo elsifCase = new Nodo();
                elsifCase.setEtiqueta("Else if");
                elsifCase.setID(parser.count);
                elsifCase.setValor(elsifer.toString());
                parser.count++;

                elsifCase.addHijos((Nodo) ex);
                elsifCase.addHijos((Nodo) prop);

                //if(elseR!=null){
                //        elsifCase.addHijos(((Nodo) elseR).getHijos());
                //}
                elsifCase.addHijos((Nodo) elseR);
                RESULT = elsifCase;

        :}
        | ELSE LCBRACKET proposition:prop RCBRACKET{:
                Nodo elseFinal = new Nodo();
                elseFinal.setEtiqueta("Else final");
                elseFinal.setID(parser.count);
                elseFinal.setValor("ELSE");
                parser.count++;

                elseFinal.addHijos((Nodo) prop);

                RESULT = elseFinal;

        :}
        | {::};


switchCase ::= SWITCH LPAR ID RPAR LCBRACKET cases RCBRACKET;

cases::= CASE INTEGER COLON proposition BREAK SEMICOLON cases
        | CASE LETTERS COLON proposition BREAK SEMICOLON cases
        | DEFAULT COLON proposition BREAK SEMICOLON;

expression ::= expresion_simple:exS{:
                RESULT = exS;
        :}
	| expresion_simple:exSL OPREL:opr expresion_simple:exSR{:
                Nodo exprOprel = new Nodo ();
                exprOprel.setEtiqueta("Expr con oprel");
                exprOprel.setID(parser.count);
                parser.count++;

                exprOprel.addHijos((Nodo) exSL);

                Nodo oprelN = new Nodo();
                oprelN.setEtiqueta("op relacional");
                oprelN.setID(parser.count);
                oprelN.setValor(opr.toString());

                parser.count++;

                exprOprel.addHijos((Nodo) exSR);

                RESULT = exprOprel;
        :};

expresion_simple ::= termino:term{:
                RESULT = term;
        :}
	| signo:sig termino:term{:
                Nodo signTERM = new Nodo();
                signTERM.setID(parser.count);
                signTERM.setEtiqueta("termino con signo");
                parser.count++;
                
                signTERM.addHijos((Nodo) sig);
                signTERM.addHijos((Nodo) term);

                RESULT = signTERM;
        :}
	| expresion_simple:exS  OPSUMA:opS termino:term {:
                Nodo exTERM = new Nodo();
                exTERM.setID(parser.count);
                exTERM.setEtiqueta("expr suma termino");
                parser.count++;

                exTERM.addHijos((Nodo) exS);
                Nodo simbolo = new Nodo();
                simbolo.setID(parser.count);
                simbolo.setEtiqueta("Operador de suma");
                simbolo.setValor(opS.toString());
                exTERM.addHijos((Nodo) term);

                RESULT = exTERM;

        :};

termino ::= factor:factorX {:
                RESULT = factorX;
        :}
	| termino:term OPMULT:opM factor:fac{:
                Nodo termFactor = new Nodo();
                termFactor.setID(parser.count);
                termFactor.setEtiqueta("Termino con factor");
                parser.count++;

                termFactor.addHijos((Nodo) term);
                Nodo simbolo = new Nodo();
                simbolo.setID(parser.count);
                simbolo.setEtiqueta("Operador de Mult");
                simbolo.setValor(opM.toString());
                parser.count++;

                termFactor.addHijos((Nodo) fac);

                RESULT = termFactor;
                
        :};

factor ::= ID:idP{:
                Nodo idData = new Nodo();
                idData.setEtiqueta("ID");
                idData.setID(parser.count);
                idData.setValor(idP.toString());
                parser.count++;

                RESULT = idData;
        :}
	| ID LPAR lista_expresiones RPAR {:

        :}
	| values:vals{:
                RESULT = vals;
        :}
	| LPAR expression:ex RPAR{:
                RESULT = ex;
        :}
	| NOT:nt factor:fac{:
                Nodo notF = new Nodo();
                notF.setEtiqueta("Not factor");
                notF.setID(parser.count);
                parser.count++;

                Nodo notW = new Nodo();
                notW.setEtiqueta("Not");
                notW.setID(parser.count);
                notW.setValor(nt.toString());
                parser.count++;

                notF.addHijos(notW);
                notF.addHijos((Nodo)fac);

                RESULT = notF;

        :};

//factor_for ::= ID
//	| INT
//	| signo INT;

signo ::= OPSUMA:opSum{:
        Nodo operador = new Nodo();
        operador.setEtiqueta("opSuma");
        operador.setID(parser.count);
        operador.setValor(opSum.toString());
        parser.count++;

        RESULT = operador;
:};

lista_expresiones::= expression:ex {:
                RESULT = ex;
:} | lista_expresiones COMMA expression{:

:};

     


