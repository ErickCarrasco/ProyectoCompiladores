package main;

import java_cup.runtime.*;
import java.util.*;
import java.io.FileReader;
//import Nodo;

parser code
{:
        public int count=1;
        public static Nodo padre;
        public static int syntacticErrors = 0;

        public String token_name_from_id(int id){
                //por medio de SYM.JAVA
                case 0: return "EOF";
                case 1: return "error";
                case 2: return "BOOL";
                case 3: return "LETTERS";
                case 4: return "INTEGER";
                case 5: return "NOTHING";
                case 6: return "ID";
                case 7: return "LPAR";
                case 8: return "RPAR";
                case 9: return "LSBRACKET";
                case 10: return "RSBRACKET";
                case 11: return "LCBRACKET";
                case 12: return "RCBRACKET";
                case 13: return "COLON";
                case 14: return "ASSIGNMENT";
                case 15: return "SEMICOLON";
                case 16: return "COMMA";
                case 17: return "OPREL";
                case 18: return "OPSUMA";
                case 19: return "OPMULT";
                case 20: return "OPRES";
                case 21: return "VECTOR";
                case 22: return "CASE";
                case 23: return "IF";
                case 24: return "WHILE";
                case 25: return "LOOP";
                case 26: return "ELSIF";
                case 27: return "ELSE";
                case 28: return "FUNC";
                case 29: return "PIPE";
                case 30: return "SCAN";
                case 31: return "SOUT";
                case 32: return "SOUTLN";
                case 33: return "BREAK";
                case 34: return "DEFAULT";
                case 35: return "SWITCH";
                case 36: return "INT";
                case 37: return "DEF";
                case 38: return "FAKER";
                case 39: return "PAYBACK";
                case 40: return "EACH";
                case 41: return "INIT";
                case 42: return "NOT";
                case 43: return "CHAR";

        }

        public void syntax_error(Symbol s){
                report_error("Error sintáctico. No se esperaba el siguiente token: <" + s.value + ">. Línea: " + (s.right + 1) + ", Columna: " + (s.left + 1) + 	"\n", null);

                syntacticErrors++;

                List expected = expected_token_ids();
                if (expected.size() != 0) {
                        int id;
                        System.out.println("Se esperaba...");
                        for (int i = 0; i < expected.size(); i++) {
            	                id = (int) expected.get(i);
            	                if (i == expected.size() - 1) {
            		                System.out.println(token_name_from_id(id));
            	                } else {
            		                System.out.print(token_name_from_id(id) + " | ");
            	                }
                        }
                }

        }

:}

//Lexemas
terminal   BOOL, LETTERS, INTEGER, NOTHING;
terminal   ID;


//Palabras reservadas, y Operadores
terminal LPAR, RPAR, LSBRACKET, RSBRACKET, LCBRACKET, RCBRACKET, COLON, ASSIGNMENT, SEMICOLON, COMMA;

terminal OPREL, OPSUMA, OPMULT, OPRES, VECTOR, CASE, IF, WHILE, LOOP, ELSIF, ELSE, FUNC, PIPE;

terminal SCAN, SOUT, SOUTLN, BREAK, DEFAULT, SWITCH, INT, DEF, FAKER, PAYBACK, EACH, INIT, NOT;

terminal CHAR;

//No TERMINALES

non terminal Program;
non terminal declaraciones;
non terminal decl_v_e;
non terminal declaracion_vec;
non terminal tipo;
non terminal tipoVS;
non terminal values;
non terminal ifStatement;
non terminal expression;
non terminal expresion_simple;
non terminal termino;
non terminal factor;

non terminal signo;
non terminal declaracionSimple;
non terminal functions;
non terminal params;
non terminal elsiffer;
non terminal proposition;
non terminal asignacion;
non terminal forLoop;
non terminal switchCase;
non terminal cases;
non terminal body;
non terminal vectorData;
non terminal empty;
non terminal lista_ID;
non terminal lista_expresiones;
non terminal imprimir;
non terminal scanear;

start with Program;

Program ::= INIT:initProg LPAR:leftPar RPAR:rightPar LCBRACKET:left_cbracket body:mainbody RCBRACKET:right_cbracket 
        {:
                Nodo nodo = new Nodo();
                nodo.setEtiqueta("INITIALIZE");
                nodo.setID(parser.count);
                parser.count++;

                //Terminal init
                Nodo initProg = new Node();
                initp.setEtiqueta("INIT");
                initp.setID(parser.count);
                parser.count++;
                //initp.setValor(id);

                nodo.addHijos(initp);

                //Terminal leftPar
                Nodo leftPar = new Node();
                leftPar.setEtiqueta("(");
                leftPar.setID(parser.count);
                parser.count++;

                nodo.addHijos(leftPar);

                //Terminal rightPar
                Nodo rightPar = new Node();
                rightPar.setEtiqueta(")");
                rightPar.setID(parser.count);
                parser.count++;

                nodo.addHijos(rightPar);

                //Terminal left C bracket
                Nodo left_cbracket = new Node();
                left_cbracket.setEtiqueta("(");
                left_cbracket.setID(parser.count);
                parser.count++;
                nodo.addHijos(left_cbracket);

                //Non terminal body
                nodo.addHijos((Nodo) mainbody);

                //Terminal Right C Bracket
                Nodo right_cbracket = new Node();
                right_cbracket.setEtiqueta(")");
                right_cbracket.setID(parser.count);
                parser.count++;
                nodo.addHijos(right_cbracket);

                parser.padre = nodo;

                RESULT = nodo;
        :}
        ;


declaraciones ::=  DEF  tipo  lista_ID SEMICOLON;

body::= proposition body 
        | functions body
        | {::};

proposition ::= WHILE expression LCBRACKET proposition RCBRACKET
        | forLoop
        | ifStatement
        | switchCase
        | declaraciones
        | declaracionSimple
        | imprimir
        | scanear
        | ID ASSIGNMENT expression SEMICOLON;

imprimir ::= SOUT LPAR ID RPAR SEMICOLON
        | SOUTLN LPAR ID RPAR SEMICOLON
        | SOUT LPAR values RPAR SEMICOLON 
        | SOUTLN LPAR values RPAR SEMICOLON;


forLoop::= LOOP LSBRACKET proposition RSBRACKET EACH LPAR ID RPAR;

declaracionSimple ::= DEF tipo ID decl_v_e;

functions::= FUNC tipo ID LPAR params RPAR LCBRACKET body PAYBACK values SEMICOLON RCBRACKET;

params::= tipo ID
    | ID;

scanear::= SCAN LPAR values RPAR SEMICOLON;

lista_ID ::= ID lista_ID
        | COMMA lista_ID
        | empty;

decl_v_e ::= SEMICOLON
        |   asignacion;

asignacion ::= ASSIGNMENT values SEMICOLON
        | ASSIGNMENT NOTHING SEMICOLON;


tipo ::= 
        INT |
        FAKER |
        CHAR;

tipoVS ::= DEF VECTOR ID ASSIGNMENT vectorData;

vectorData ::= LSBRACKET vectorData RSBRACKET
        | values COMMA;

values ::= BOOL
        | LETTERS
        | INTEGER;

//ifStatement::= ifEmp | ifNEmp;

//ifEmp::= IF expression LCBRACKET proposition RCBRACKET elsiffer;

//ifNEmp::= IF expression LCBRACKET proposition RCBRACKET;

ifStatement ::= IF  expression  LCBRACKET proposition RCBRACKET elsiffer;

elsiffer::= ELSIF expression  LCBRACKET proposition RCBRACKET elsiffer
        | ELSE LCBRACKET proposition RCBRACKET
        | {::};


switchCase ::= SWITCH LPAR ID RPAR LCBRACKET cases RCBRACKET;

cases::= CASE INTEGER COLON proposition BREAK SEMICOLON cases
        | CASE LETTERS COLON proposition BREAK SEMICOLON cases
        | DEFAULT COLON proposition BREAK SEMICOLON;

expression ::= expresion_simple
	| expresion_simple OPREL expresion_simple;

expresion_simple ::= termino
	| signo termino
	| expresion_simple OPSUMA termino;

termino ::= factor
	| termino OPMULT factor;

factor ::= ID
	| ID LPAR lista_expresiones RPAR
	| values
	| LPAR expression RPAR
	| NOT factor;

//factor_for ::= ID
//	| INT
//	| signo INT;

signo ::= OPSUMA;

lista_expresiones::= expression | lista_expresiones COMMA expression;

     


